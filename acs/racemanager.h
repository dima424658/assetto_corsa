#pragma once

class RaceManager
{
void RaceManager::RaceManager(Sim *isim);
void RaceManager::~RaceManager();
RaceManager *RaceManager::`vector deleting destructor'(unsigned int a2);
void RaceManager::checkMandatoryPit(int carIndex, float entry, float exit);
Session *RaceManager::convertRemoteSession(Session *result, const RemoteSession *rs);
void RaceManager::finalizeCurrentSession();
void RaceManager::generateWind();
Lap *RaceManager::getBestLap(Lap *result, CarAvatar *car);
unsigned int RaceManager::getBestLap();
unsigned int RaceManager::getBestSplit(const int *sector, const bool *isGlobal, CarAvatar *car);
unsigned int RaceManager::getCarLeaderboardPosition(CarAvatar *car);
unsigned int RaceManager::getCarRealTimePosition(CarAvatar *car);
Lap *RaceManager::getCurrentLap(Lap *result, CarAvatar *car);
Session *RaceManager::getCurrentSession(Session *result);
int RaceManager::getCurrentSessionIndex();
SessionType RaceManager::getCurrentSessionType();
bool RaceManager::getHasCompletedFlag(CarAvatar *car);
CarAvatar *RaceManager::getInstanceBestLap(CarAvatar *car);
int RaceManager::getInvertedGridPositions();
int RaceManager::getLapCount(CarAvatar *car);
std::vector<Lap> *RaceManager::getLaps(std::vector<Lap> *result, CarAvatar *car, bool readReplayModeIfActive);
Lap *RaceManager::getLastLap(Lap *result, CarAvatar *car);
unsigned int RaceManager::getLastSplit(CarAvatar *car, const int *sector);
unsigned int RaceManager::getLeaderLapCount();
std::vector<LeaderboardEntry> *RaceManager::getLeaderboard(std::vector<LeaderboardEntry> *result);
std::vector<LeaderboardEntry> *RaceManager::getLeaderboardFromSession(std::vector<LeaderboardEntry> *result, int sessionID);
std::vector<std::wstring> *RaceManager::getModelSkins(std::vector<std::wstring> *result, const std::wstring *model);
unsigned __int16 RaceManager::getPitWindowEnd();
unsigned __int16 RaceManager::getPitWindowStart();
std::wstring *RaceManager::getPracticeQualifyText(std::wstring *result);
std::wstring *RaceManager::getRaceText(std::wstring *result);
int RaceManager::getSessionCount();
OnSessionEndEvent *RaceManager::getSessionHistory(OnSessionEndEvent *result, const int *sessionID);
Session *RaceManager::getSessionInfo(Session *result, int sessionIndex);
long double RaceManager::getSessionTimeLeft();
int RaceManager::getSessionTotalTime(unsigned int carIndex);
int RaceManager::getSplit(CarAvatar *car);
unsigned int RaceManager::getSplit(CarAvatar *car, const int *sector);
double RaceManager::getTimeToSessionStart();
long double RaceManager::getTimetoWait();
bool RaceManager::hasExtraLap();
bool RaceManager::hasSessionStarted();
void RaceManager::initGhostcar(INIReaderDocuments *ini);
void RaceManager::initLighting(INIReaderDocuments *ini);
// char __userpurge RaceManager::initOffline@<al>(@<ecx>, __m128 a2@<xmm0>, __m128 a3@<xmm3>, __m128 a4@<xmm4>, INIReaderDocuments *anIniReader);
// char __userpurge RaceManager::initOnline@<al>(@<ecx>, __m128 a2@<xmm3>, __m128 a3@<xmm4>, INIReaderDocuments *ini);
// char __userpurge RaceManager::initReplay@<al>(@<ecx>, __m128 a2@<xmm3>, __m128 a3@<xmm4>, INIReaderDocuments *r);
bool RaceManager::isBestSplit(const int *sector, const int *t, const bool *isGlobal, CarAvatar *car);
char RaceManager::isRaceOver(unsigned int carIndex);
bool RaceManager::isSkinAvailable(const std::wstring *model, const std::wstring *skin);
void RaceManager::onLapCompleted(const OnLapCompletedEvent *message);
void RaceManager::renderHUD(float dt);
void RaceManager::resetCurrentLaps();
void RaceManager::resetInvalidStateCarsToPits(float dt);
void RaceManager::resetMandatoryPit();
void RaceManager::restartCurrentSession();
void RaceManager::setCurrentSession(unsigned int index);
void RaceManager::setHasCompletedFlag(CarAvatar *car, bool value);
void RaceManager::shutdown();
char RaceManager::skipCurrentSession();
void RaceManager::startRace(float millisecondsToStart);
void RaceManager::update(float deltaT);
void RaceManager::updateCarsEndRace(float dt);
void RaceManager::updateCarsRealTimePositions(float dt);
bool RaceManager::isOfficialSpecialEvent();

};